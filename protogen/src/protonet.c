/* This file was autogenerated. All changes will be undone. */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <protonet.h>
#include <protonet_parser.h>
#include <message.h>
#include <datalink.h>
#include <serial.h>
#include <udp.h>
#include <queue.h>
#include <thread.h>

using namespace protonet;

node::node(uint8_t node_id)
{ 
	memset(datalinks,0,sizeof(datalinks));
	num_datalinks = 0;

	null_callback_storage();

	/* destroy pointer and node in the event of invalid id */
	if(node_id == 0)
	{
		this->~node();
		return;
	}
	this->node_id = node_id;

	thread_create(&handler_thread, &node::handler_helper, this);
	queue = proto_msg_queue();
}

/* Create a node with a specified mode, TBD */
node::node(uint8_t node_id, int32_t mode)
{ 
	memset(datalinks,0,sizeof(datalinks));
	num_datalinks = 0;

	null_callback_storage();

	if(node_id == 0)
	{
		this->~node();
		return;
	}
	this->node_id = node_id;

	//thread_create(&handler_thread, &node::handler_helper, this);
	queue = proto_msg_queue();
}
node::~node()
{
	int32_t i;
	for(i = 0; i<num_datalinks; i++)
	{
		datalinks[i]->close();
	}

}

/* Need to call start to create the protonet handler, usually after establish functions */
void node::start()
{
	try
	{
		//thread_create(&upkeep_thread, &node::upkeep_helper, this);
	}
	catch(int e)
	{
		printf("thread_create out: %d\n", e);
	
	}
}

/* Entry point for the event handler that performs callbacks based on incoming messages */
void* node::protonet_handler()
{
	proto_msg_t proto_msg;	
	while(1)
	{
		/* Blocking call to the message queue, unblock when messages are in queue */
		queue.remove(&proto_msg);
		{
			{				
				/* Behavior on an outgoing message from client*/
				if(proto_msg.direction == Proto_Out)
				{
//#ifdef DEBUG
					printf("Node %d Outbound: Source id: %d, Dest. id %d, Message type: %s\n", this->node_id,proto_msg.header.node_src_id, proto_msg.header.node_dest_id, proto_typestr((proto_msg_type)proto_msg.header.message_type));
//#endif
					int32_t i;
					if(num_datalinks>0)
					{
						for(i = 0;i<num_datalinks;i++)
						{
							datalinks[i]->send(proto_msg.header.node_dest_id, proto_msg.data, proto_msg.tx_len);
						}
					}
				}
				/* Behavior on an incoming message from client*/
				else if(proto_msg.direction == Proto_In)				
				{
//#ifdef DEBUG
					printf("Node %d Inbound: Source id: %d, Dest. id %d, Message type: %s\n", this->node_id,proto_msg.header.node_src_id, proto_msg.header.node_dest_id, proto_typestr((proto_msg_type)proto_msg.header.message_type));
//#endif
					if((proto_msg.header.node_dest_id == this->node_id) || (proto_msg.header.node_dest_id == 0))
					{

						proto_msg_buf_t rx_buf;
						/* Unpack and identify the type of incoming message */
						unpack_proto_msg_t(&proto_msg, &rx_buf);
						/* Perform a callback based on message type */
						handle_proto_msg_t(&proto_msg, &rx_buf);
					}
				}
			}
		}
	}
	return 0;
}

void* node::upkeep_handler()
{
	while(1)
	{
		this->send_enter();
#ifdef _WIN32
		_sleep(5000);
#endif
#ifdef __unix__
		delay(5000);
#endif
	}
	return 0;
}

void node::add_serial(int8_t* link_id, uint32_t baud_rate, char device_path[50])
{
	/* Initialize a datalink pointer as a Serial link */
	datalinks[num_datalinks] = new Serial();

	/* Cast the datalink as a Serial datalink and open it with required options */
	if(((Serial*)(datalinks[num_datalinks]))->open(baud_rate, device_path) == 0)
	{
		/* Provide a reference to the queue for access to protonet handler, runs the datalink */
		datalinks[num_datalinks]->set_link_id(num_datalinks);
		datalinks[num_datalinks]->set_queue(&this->queue);
		datalinks[num_datalinks]->run();

		/* Provide the link_id for future reference, simply increment to keep track */
		*link_id = num_datalinks;
		num_datalinks++;
	}
}


void node::add_udp(int8_t* link_id, uint16_t port)
{
	/* Follows the same format as the above function, except UDP oriented */
	datalinks[num_datalinks] = new UDP(port);
	if(datalinks[num_datalinks]->is_connected())
	{
		datalinks[num_datalinks]->set_link_id(num_datalinks);
		datalinks[num_datalinks]->set_queue(&this->queue);
		datalinks[num_datalinks]->run();
		*link_id = num_datalinks;
		num_datalinks++;
	}
}
	
void node::add_udp(int8_t* link_id, uint16_t port, char addr[16])
{
	/* 
	Follows the same format as the above function, 
	except targets an interface specified by IP
	*/
	datalinks[num_datalinks] = new UDP(port, addr);
	if(datalinks[num_datalinks]->is_connected())
	{
		datalinks[num_datalinks]->set_link_id(num_datalinks);
		datalinks[num_datalinks]->set_queue(&this->queue);
		datalinks[num_datalinks]->run();
		*link_id = num_datalinks;
		num_datalinks++;
	}
}

void node::establish_serial(int8_t link_id, uint8_t node_id)
{
	/* 
	Check that the datalink is of the correct type & connected, 
	and set the node_id 
	*/
	if(datalinks[link_id]->get_datalink_type() == SERIAL_TYPE && datalinks[link_id]->is_connected())
	{
		datalinks[link_id]->establish(node_id);
	}
	
}
void node::establish_udp(int8_t link_id, uint8_t node_id, uint16_t port, char addr[16])
{
	/* This is similar to the Serial establish function, except for UDP */
	if(datalinks[link_id]->get_datalink_type()== UDP_TYPE && datalinks[link_id]->is_connected())
	{
		((UDP*)datalinks[link_id])->establish(node_id, port, addr);
	}
}

uint8_t node::get_num_datalinks()
{
	return(this->num_datalinks);
}

int32_t node::query_datalink_connected(int8_t link_id)
{
	/* Returns 1 if the datalink is connected */
	return(datalinks[link_id]->is_connected());
}

datalink_type_t node::query_datalink_type(int8_t link_id)
{
	return(datalinks[link_id]->get_datalink_type());
}

/* Helper functions from C style from C++ entry point with class member linkage */
void* node::handler_helper(void* context)
{
	return ((node*)context)->protonet_handler();
}

void* node::upkeep_helper(void* context)
{
	return ((node*)context)->upkeep_handler();
}

void node::null_callback_storage()
{
   on_UGV_joystick = NULL;
   on_UGV_battery_status = NULL;
}
void node::handle_proto_msg_t(proto_msg_t* rx_msg, proto_msg_buf_t* rx_buf)
{
   switch(rx_msg->header.message_type)
   {
   case Proto_UGV_Joystick:
      {
         if(on_UGV_joystick == NULL)
         {
         }
         else
         {
            this->on_UGV_joystick(rx_msg->link_id, rx_msg->header, rx_buf->UGV_joystick, this);
         }
         break;
      }
   case Proto_UGV_Battery_Status:
      {
         if(on_UGV_battery_status == NULL)
         {
         }
         else
         {
            this->on_UGV_battery_status(rx_msg->link_id, rx_msg->header, rx_buf->UGV_battery_status, this);
         }
         break;
      }
   }
}

void send_UGV_joystick(
   uint8_t dest_id,
   uint8_t vehicle_id,
   float32_t steering,
   float32_t throttle)
{
   proto_msg_t proto_msg;
   UGV_joystick_t UGV_joystick;
   UGV_joystick.vehicle_id = vehicle_id;
   UGV_joystick.steering = steering;
   UGV_joystick.throttle = throttle;
   encode_UGV_joystick(this->node_id, dest_id, 3, 0, &UGV_joystick, &proto_msg);
   queue.add(&proto_msg);
   return;
}

void send_UGV_battery_status(
   uint8_t dest_id,
   float64_t timestamp,
   float64_t 3_3V_voltage,
   float64_t 5V_voltage,
   float64_t 12V_voltage,
   float64_t 3_3V_current,
   float64_t 5V_current,
   float64_t 12V_current)
{
   proto_msg_t proto_msg;
   UGV_battery_status_t UGV_battery_status;
   UGV_battery_status.timestamp = timestamp;
   UGV_battery_status.3_3V_voltage = 3_3V_voltage;
   UGV_battery_status.5V_voltage = 5V_voltage;
   UGV_battery_status.12V_voltage = 12V_voltage;
   UGV_battery_status.3_3V_current = 3_3V_current;
   UGV_battery_status.5V_current = 5V_current;
   UGV_battery_status.12V_current = 12V_current;
   encode_UGV_battery_status(this->node_id, dest_id, 3, 0, &UGV_battery_status, &proto_msg);
   queue.add(&proto_msg);
   return;
}

